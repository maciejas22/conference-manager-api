package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"errors"

	"github.com/maciejas22/conference-manager-api/cm-gateway/internal/graph"
	"github.com/maciejas22/conference-manager-api/cm-gateway/internal/graph/model"
	middlewares "github.com/maciejas22/conference-manager-api/cm-gateway/internal/middleware"
	authPb "github.com/maciejas22/conference-manager-api/cm-proto/auth"
	commonPb "github.com/maciejas22/conference-manager-api/cm-proto/common"
	conferencePb "github.com/maciejas22/conference-manager-api/cm-proto/conference"
	stripe "github.com/stripe/stripe-go/v81"
	"github.com/stripe/stripe-go/v81/account"
	"github.com/stripe/stripe-go/v81/accountlink"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, loginUserInput model.LoginUserInput) (string, error) {
	s, err := r.authServiceClient.Login(ctx, &authPb.LoginRequest{
		Email:    loginUserInput.Email,
		Password: loginUserInput.Password,
	})
	if err != nil {
		return "", gqlerror.Errorf(err.Error())
	}

	return s.SessionId, nil
}

// RegisterUser is the resolver for the registerUser field.
func (r *mutationResolver) RegisterUser(ctx context.Context, registerUserInput model.RegisterUserInput) (int32, error) {
	var stripeAccountId *string
	if registerUserInput.Role == model.RoleOrganizer {
		account, err := account.New(&stripe.AccountParams{
			Email: stripe.String(registerUserInput.Email),
		})
		if err != nil {
			return 0, errors.New("Failed to create stripe account")
		}
		stripeAccountId = &account.ID
	}

	var userRole authPb.Role
	switch registerUserInput.Role {
	case model.RoleOrganizer:
		userRole = authPb.Role_ROLE_ORGANIZER
	case model.RoleParticipant:
		userRole = authPb.Role_ROLE_PARTICIPANT
	}

	u, err := r.authServiceClient.Register(ctx, &authPb.RegisterRequest{
		Email:           registerUserInput.Email,
		Password:        registerUserInput.Password,
		Role:            userRole,
		StripeAccountId: *stripeAccountId,
	})
	if err != nil {
		return 0, gqlerror.Errorf(err.Error())
	}

	return u.UserId, nil
}

// StripeOnboard is the resolver for the stripeOnboard field.
func (r *mutationResolver) StripeOnboard(ctx context.Context, returnURL string, refreshURL string) (string, error) {
	si := middlewares.GetSessionInfo(ctx)
	accountLink, err := accountlink.New(&stripe.AccountLinkParams{
		Account:    stripe.String(si.StripeAccountId),
		ReturnURL:  stripe.String(returnURL),
		RefreshURL: stripe.String(refreshURL),
		Type:       stripe.String("account_onboarding"),
	})
	if err != nil {
		return "", gqlerror.Errorf("Failed to create account link")
	}

	return accountLink.URL, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	si := middlewares.GetSessionInfo(ctx)
	u, err := r.authServiceClient.Logout(ctx, &authPb.LogoutRequest{
		SessionId: si.SessionId,
	})
	if err != nil {
		return false, gqlerror.Errorf(err.Error())
	}

	return u.IsSuccess, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, updateUserInput model.UpdateUserInput) (int32, error) {
	si := middlewares.GetSessionInfo(ctx)
	u, err := r.authServiceClient.UpdateUserProfile(ctx, &authPb.UpdateUserProfileRequest{
		UserId:   si.UserId,
		Name:     updateUserInput.Name,
		Surname:  updateUserInput.Surname,
		Email:    updateUserInput.Email,
		Username: updateUserInput.Username,
	})
	if err != nil {
		return 0, gqlerror.Errorf(err.Error())
	}

	return u.UserId, nil
}

// EditPassword is the resolver for the editPassword field.
func (r *mutationResolver) EditPassword(ctx context.Context, password string) (*bool, error) {
	si := middlewares.GetSessionInfo(ctx)
	_, err := r.authServiceClient.UpdateUserProfile(ctx, &authPb.UpdateUserProfileRequest{
		UserId:   si.UserId,
		Password: password,
	})
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	var success = true
	return &success, nil
}

func (r *mutationResolver) UpdateSession(ctx context.Context) (string, error) {
	si := middlewares.GetSessionInfo(ctx)
	s, err := r.authServiceClient.UpdateSession(ctx, &authPb.UpdateSessionRequest{
		SessionId: si.SessionId,
	})
	if err != nil {
		return "", gqlerror.Errorf(err.Error())
	}
	return s.SessionId, nil
}

// NewParticipantsTrend is the resolver for the newParticipantsTrend field.
func (r *organizerMetricsResolver) NewParticipantsTrend(ctx context.Context, obj *model.OrganizerMetrics) ([]*model.NewParticipantsTrend, error) {
	si := middlewares.GetSessionInfo(ctx)
	t, err := r.conferenceServiceClient.GetParticipantsTrend(ctx, &conferencePb.ParticipantsTrendRequest{
		UserId: si.UserId,
	})
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	var trends []*model.NewParticipantsTrend
	for _, trend := range t.Trend {
		trends = append(trends, &model.NewParticipantsTrend{
			Date:            trend.Date.AsTime(),
			NewParticipants: trend.NewParticipants,
		})
	}
	return trends, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context) (*model.User, error) {
	si := middlewares.GetSessionInfo(ctx)
	u, err := r.authServiceClient.UserProfileBySession(ctx, &authPb.UserProfileBySessionRequest{
		SessionId: si.SessionId,
	})
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	var role model.Role
	switch u.User.Role {
	case authPb.Role_ROLE_ORGANIZER:
		role = model.RoleOrganizer
	case authPb.Role_ROLE_PARTICIPANT:
		role = model.RoleParticipant
	}

	return &model.User{
		ID:       u.User.UserId,
		Name:     &u.User.Name,
		Surname:  &u.User.Surname,
		Email:    u.User.Email,
		Username: &u.User.Username,
		Role:     role,
	}, nil
}

// IsUserAssociatedWithConference is the resolver for the isUserAssociatedWithConference field.
func (r *queryResolver) IsUserAssociatedWithConference(ctx context.Context, conferenceID int32) (bool, error) {
	si := middlewares.GetSessionInfo(ctx)
	ok, err := r.conferenceServiceClient.IsUserAssociatedWithConference(ctx, &conferencePb.IsUserAssociatedWithConferenceRequest{
		UserId:       si.UserId,
		ConferenceId: conferenceID,
	})
	if err != nil {
		return false, gqlerror.Errorf(err.Error())
	}

	return ok.IsAssociated, nil
}

// Metrics is the resolver for the metrics field.
func (r *userResolver) Metrics(ctx context.Context, obj *model.User) (*model.OrganizerMetrics, error) {
	m, err := r.conferenceServiceClient.GetOrganizerMetrics(ctx, &conferencePb.GetOrganizerMetricsRequest{
		UserId: obj.ID,
	})
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	return &model.OrganizerMetrics{
		RunningConferences:        m.RunningConferences,
		ParticipantsCount:         m.ParticipantsCount,
		AverageParticipantsCount:  float64(m.AverageParticipantsCount),
		TotalOrganizedConferences: m.TotalOrganizedConferences,
	}, nil
}

// Tickets is the resolver for the tickets field.
func (r *userResolver) Tickets(ctx context.Context, obj *model.User, page model.Page) (*model.TicketsPage, error) {
	si := middlewares.GetSessionInfo(ctx)
	t, err := r.conferenceServiceClient.GetTickets(ctx, &conferencePb.TicketsRequest{
		UserId: si.UserId,
		Page: &commonPb.Page{
			Number: (page.Number),
			Size:   (page.Size),
		},
	})
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}
	var cIds []int32
	for _, ticket := range t.TicketsPage.Data {
		cIds = append(cIds, ticket.ConferenceId)
	}

	c, err := r.conferenceServiceClient.GetConferences(ctx, &conferencePb.ConferencesRequest{
		ConferenceIds: cIds,
	})
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	confMap := make(map[int32]*conferencePb.Conference)
	for _, conference := range c.Conferences {
		confMap[conference.Id] = conference
	}

	var tickets []*model.Ticket
	for _, ticket := range t.TicketsPage.Data {
		registrationDeadline := confMap[ticket.ConferenceId].RegistrationDeadline.AsTime()
		tickets = append(tickets, &model.Ticket{
			ID: ticket.TicketId,
			Conference: &model.Conference{
				ID:                   confMap[ticket.ConferenceId].Id,
				Title:                confMap[ticket.ConferenceId].Title,
				StartDate:            confMap[ticket.ConferenceId].StartDate.AsTime(),
				EndDate:              confMap[ticket.ConferenceId].EndDate.AsTime(),
				Location:             confMap[ticket.ConferenceId].Location,
				Website:              &confMap[ticket.ConferenceId].Website,
				Acronym:              &confMap[ticket.ConferenceId].Acronym,
				AdditionalInfo:       &confMap[ticket.ConferenceId].AdditionalInfo,
				ParticipantsCount:    confMap[ticket.ConferenceId].ParticipantsCount,
				ParticipantsLimit:    &confMap[ticket.ConferenceId].ParticipantsLimit,
				RegistrationDeadline: &registrationDeadline,
				EventsCount:          confMap[ticket.ConferenceId].EventsCount,
				TicketPrice:          &confMap[ticket.ConferenceId].TicketPrice,
			},
		})
	}

	return &model.TicketsPage{
		Data: tickets,
		Meta: &model.PageInfo{
			TotalPages: t.TicketsPage.Meta.Page.TotalPages,
			TotalItems: t.TicketsPage.Meta.Page.TotalItems,
			Number:     t.TicketsPage.Meta.Page.Number,
			Size:       t.TicketsPage.Meta.Page.Size,
		},
	}, nil
}

// StripeAccountDetails is the resolver for the stripeAccountDetails field.
func (r *userResolver) StripeAccountDetails(ctx context.Context, obj *model.User) (*model.StripeAccountDetails, error) {
	si := middlewares.GetSessionInfo(ctx)
	acc, err := account.GetByID(si.StripeAccountId, nil)
	if err != nil {
		return nil, gqlerror.Errorf("Failed to get stripe account details")
	}

	return &model.StripeAccountDetails{
		ID:         acc.ID,
		IsVerified: acc.ChargesEnabled && acc.PayoutsEnabled,
	}, nil
}

func (r *Resolver) OrganizerMetrics() graph.OrganizerMetricsResolver {
	return &organizerMetricsResolver{r}
}

func (r *Resolver) User() graph.UserResolver { return &userResolver{r} }

type organizerMetricsResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
