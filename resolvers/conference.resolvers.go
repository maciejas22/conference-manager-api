package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"
	"time"

	"github.com/maciejas22/conference-manager/api/db/repositories"
	"github.com/maciejas22/conference-manager/api/graph"
	"github.com/maciejas22/conference-manager/api/internal/auth"
	"github.com/maciejas22/conference-manager/api/models"
	"github.com/maciejas22/conference-manager/api/utils"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

func (r *conferenceResolver) Agenda(ctx context.Context, obj *models.Conference) ([]*models.AgendaItem, error) {
	agenda, err := r.agendaRepo.GetAgenda(obj.ID)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	var agendaItems []*models.AgendaItem
	for _, a := range agenda {
		parsedStartTime, err := time.Parse(time.RFC3339Nano, a.StartTime)
		if err != nil {
			return nil, gqlerror.Errorf(err.Error())
		}
		parsedEndTime, err := time.Parse(time.RFC3339Nano, a.EndTime)
		if err != nil {
			return nil, gqlerror.Errorf(err.Error())
		}

		agendaItems = append(agendaItems, &models.AgendaItem{
			ID:        a.Id,
			StartTime: parsedStartTime,
			EndTime:   parsedEndTime,
			Event:     a.Event,
			Speaker:   a.Speaker,
		})
	}

	return agendaItems, nil
}

func (r *conferenceResolver) ParticipantsCount(ctx context.Context, obj *models.Conference) (int, error) {
	conferenceId := obj.ID

	participantsCount, err := r.conferenceParticipantRepo.GetParticipantsCount(conferenceId)
	if err != nil {
		return 0, gqlerror.Errorf(err.Error())
	}

	return participantsCount, nil
}

func (r *mutationResolver) CreateConference(ctx context.Context, createConferenceInput models.CreateConferenceInput) (*models.Conference, error) {
	c, _ := auth.FromContext(ctx)
	date := createConferenceInput.Date
	dateString := utils.TimeToString(&date)
	deadlineString := utils.TimeToString(createConferenceInput.RegistrationDeadline)
	conference, err := r.conferenceRepo.CreateConference(repositories.Conference{
		Title:                createConferenceInput.Title,
		Date:                 *dateString,
		Location:             createConferenceInput.Location,
		AdditionalInfo:       createConferenceInput.AdditionalInfo,
		ParticipantsLimit:    createConferenceInput.ParticipantsLimit,
		RegistrationDeadline: deadlineString,
	}, c.Subject)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	for _, a := range createConferenceInput.Agenda {
		startTime := utils.TimeToString(&a.StartTime)
		endTime := utils.TimeToString(&a.EndTime)
		_, err = r.agendaRepo.CreateAgenda(repositories.AgendaItem{
			ConferenceId: conference.Id,
			StartTime:    *startTime,
			EndTime:      *endTime,
			Event:        a.Event,
			Speaker:      a.Speaker,
		})

		if err != nil {
			return nil, gqlerror.Errorf(err.Error())
		}
	}

	return &models.Conference{
		ID:                   conference.Id,
		Title:                conference.Title,
		Date:                 date,
		Location:             conference.Location,
		AdditionalInfo:       conference.AdditionalInfo,
		ParticipantsLimit:    conference.ParticipantsLimit,
		RegistrationDeadline: createConferenceInput.RegistrationDeadline,
	}, nil
}

func (r *mutationResolver) ModifyConference(ctx context.Context, input models.ModifyConferenceInput) (*models.Conference, error) {
	date := input.Date
	dateString := utils.TimeToString(date)
	deadlineString := utils.TimeToString(input.RegistrationDeadline)
	conference, err := r.conferenceRepo.UpdateConference(repositories.Conference{
		Id:                   input.ID,
		Title:                *input.Title,
		Date:                 *dateString,
		Location:             *input.Location,
		AdditionalInfo:       input.AdditionalInfo,
		ParticipantsLimit:    input.ParticipantsLimit,
		RegistrationDeadline: deadlineString,
	})
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	for _, a := range input.Agenda {
		startTime := utils.TimeToString(&a.StartTime)
		endTime := utils.TimeToString(&a.EndTime)

		if a.ID != nil && a.Destroy != nil && *a.Destroy {
			err = r.agendaRepo.DeleteAgenda(*a.ID)
			if err != nil {
				return nil, gqlerror.Errorf(err.Error())
			}
		} else if a.ID == nil {
			_, err = r.agendaRepo.CreateAgenda(repositories.AgendaItem{
				ConferenceId: conference.Id,
				StartTime:    *startTime,
				EndTime:      *endTime,
				Event:        a.Event,
				Speaker:      a.Speaker,
			})

			if err != nil {
				return nil, gqlerror.Errorf(err.Error())
			}

		} else if a.ID != nil {
			_, err = r.agendaRepo.UpdateAgenda(repositories.AgendaItem{
				Id:           *a.ID,
				ConferenceId: conference.Id,
				StartTime:    *startTime,
				EndTime:      *endTime,
				Event:        a.Event,
				Speaker:      a.Speaker,
			})

			if err != nil {
				return nil, gqlerror.Errorf(err.Error())
			}

		}
	}

	return &models.Conference{
		ID:                   conference.Id,
		Title:                conference.Title,
		Date:                 *date,
		Location:             conference.Location,
		AdditionalInfo:       conference.AdditionalInfo,
		ParticipantsLimit:    conference.ParticipantsLimit,
		RegistrationDeadline: input.RegistrationDeadline,
	}, nil
}

func (r *mutationResolver) AddUserToConference(ctx context.Context, conferenceID string) (*models.Conference, error) {
	c, _ := auth.FromContext(ctx)

	conference, err := r.conferenceParticipantRepo.AddParticipant(conferenceID, c.Subject)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	parsedDate := utils.ParseTime(&conference.Date)
	parsedDeadline := utils.ParseTime(conference.RegistrationDeadline)
	return &models.Conference{
		ID:                   conference.Id,
		Title:                conference.Title,
		Date:                 *parsedDate,
		Location:             conference.Location,
		AdditionalInfo:       conference.AdditionalInfo,
		ParticipantsLimit:    conference.ParticipantsLimit,
		RegistrationDeadline: parsedDeadline,
	}, nil
}

func (r *mutationResolver) RemoveUserFromConference(ctx context.Context, conferenceID string) (*models.Conference, error) {
	c, _ := auth.FromContext(ctx)

	conference, err := r.conferenceParticipantRepo.RemoveParticipant(conferenceID, c.Subject)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	parsedDate := utils.ParseTime(&conference.Date)
	parsedDeadline := utils.ParseTime(conference.RegistrationDeadline)
	return &models.Conference{
		ID:                   conference.Id,
		Title:                conference.Title,
		Date:                 *parsedDate,
		Location:             conference.Location,
		AdditionalInfo:       conference.AdditionalInfo,
		ParticipantsLimit:    conference.ParticipantsLimit,
		RegistrationDeadline: parsedDeadline,
	}, nil
}

func (r *queryResolver) Conferences(ctx context.Context, page *models.Page, sort *models.Sort, filters *models.ConferenceFilter) (*models.ConferencePage, error) {
	c, m, err := r.conferenceRepo.GetConferences(page.ToRepo(), sort.ToRepo(), filters.ToRepo())

	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}

	var conferences []*models.Conference
	for _, conference := range c {
		parsedDate := utils.ParseTime(&conference.Date)
		parsedDeadline := utils.ParseTime(conference.RegistrationDeadline)

		conferences = append(conferences, &models.Conference{
			ID:                   conference.Id,
			Title:                conference.Title,
			Date:                 *parsedDate,
			Location:             conference.Location,
			AdditionalInfo:       conference.AdditionalInfo,
			ParticipantsLimit:    conference.ParticipantsLimit,
			RegistrationDeadline: parsedDeadline,
		})
	}

	return &models.ConferencePage{
		Data: conferences,
		Meta: &models.ConferenceMeta{
			Page: &models.PageInfo{
				TotalItems: m.TotalItems,
				TotalPages: m.TotalPages,
				Number:     m.PageNumber,
				Size:       m.PageSize,
			},
		},
	}, nil
}

func (r *queryResolver) Conference(ctx context.Context, id string) (*models.Conference, error) {
	conference, err := r.conferenceRepo.GetConference(id)
	if err != nil {
		return &models.Conference{}, gqlerror.Errorf(err.Error())
	}

	parsedDate := utils.ParseTime(&conference.Date)
	parsedDeadline := utils.ParseTime(conference.RegistrationDeadline)

	return &models.Conference{
		ID:                   conference.Id,
		Title:                conference.Title,
		Date:                 *parsedDate,
		Location:             conference.Location,
		AdditionalInfo:       conference.AdditionalInfo,
		ParticipantsLimit:    conference.ParticipantsLimit,
		RegistrationDeadline: parsedDeadline,
	}, nil
}

func (r *queryResolver) IsParticipant(ctx context.Context, conferenceID string) (*bool, error) {
	c, _ := auth.FromContext(ctx)

	isParticipant, err := r.conferenceOrganizerRepo.IsOrganizer(c.Subject, conferenceID)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}
	return &isParticipant, nil
}

func (r *queryResolver) IsOrganizer(ctx context.Context, conferenceID string) (*bool, error) {
	c, _ := auth.FromContext(ctx)

	isOrganizer, err := r.conferenceOrganizerRepo.IsOrganizer(conferenceID, c.Subject)
	if err != nil {
		return nil, gqlerror.Errorf(err.Error())
	}
	return &isOrganizer, nil
}

func (r *Resolver) Conference() graph.ConferenceResolver { return &conferenceResolver{r} }

func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type conferenceResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
